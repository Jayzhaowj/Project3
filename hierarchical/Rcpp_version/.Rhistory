}
}
}
for(ts in 1:n_I){
phit[ts, , 1] <- rt*cos(2*pi/lambdat[ts, ])
}
## genrate the data sets
for(ts in 1:n_I){
for(i in 1:n_t+P){
yt_tmp[i, ts] <- t(as.matrix(yt_tmp[i-(1:P), ts]))%*%as.matrix(phit[ts, i-P, ]) + rnorm(n=1, sd = et)
}
}
return(list(yt = yt_tmp[(P+1):(n_t+P), ],
phit=phit,
lambdat=lambdat,
lambdat_mu = lambdat_mu))
}
set.seed(1234)
n_t <- 1024
n_I <- 5
P <- 2
#wt <- 0.01
vt <- 0.5
et <- .8
sim <- gen.sim(n_t = n_t, n_I = n_I, P = P, vt = vt, et = et)
yt <- sim$yt
true_ar <- sim$phit
true_ar_mean <- (0.1*(1:n_t)/n_t + 0.85)*cos(2*pi/sim$lambdat_mu)
#################################
#### draw time series and
#################################
###
layout(matrix(1:(n_I+1), nrow = 2, ncol = 3, byrow = TRUE))
for(i in 1:n_I){
draw_ts(yt[, i], ind = i)
}
#########################
###### fit model #######
#########################
F2t <- matrix(1, nrow = n_I, ncol = n_I)
F2t[1:4, 2:5] <- diag(4)
F2t[5, ] <- -1*F2t[5, ]
F2t[5,1] <- 1
delta <- seq(0.99, 0.999, 0.002)
delta_matrix <- as.matrix(expand.grid(delta, delta))
sample_size <- 1000
result_parcor <- hparcor(yt = yt, delta = delta_matrix,
P = 5, F2 = F2t, sample_size = sample_size,
chains = 1, DIC = TRUE, uncertainty = TRUE)
###########################
##### Optimal model order
###########################
P_opt <- which.min(result_parcor$DIC_fwd)
cat("Optimal model order: ", P_opt)
###########################
##### selected discount factor
###########################
print(result_parcor$best_delta_fwd)
## compute ar coefficients
coef_parcor <- PAR_to_AR_fun(phi_fwd = result_parcor$phi_fwd,
phi_bwd = result_parcor$phi_bwd)
coef <- coef_parcor[[P_opt]]$forward
## compute ar coefficients
coef_parcor_mean <- PAR_to_AR_fun(phi_fwd = result_parcor$mu_fwd,
phi_bwd = result_parcor$mu_bwd)
coef_mean <- coef_parcor_mean[[P_opt]]$forward
##
coef_sample <- lapply(1:sample_size, function(x) compute_TVAR(phi_fwd = result_parcor$phi_fwd_sample[x, , ,],
phi_bwd = result_parcor$phi_bwd_sample[x, , ,],
P_opt = P_opt))
compute_TVAR <- function(phi_fwd, phi_bwd, P_opt){
result <- PAR_to_AR_fun(phi_fwd = phi_fwd,
phi_bwd = phi_bwd)
return(result[[P_opt]]$forward)
}
##
coef_sample <- lapply(1:sample_size, function(x) compute_TVAR(phi_fwd = result_parcor$phi_fwd_sample[x, , ,],
phi_bwd = result_parcor$phi_bwd_sample[x, , ,],
P_opt = P_opt))
coef_sample <- simplify2array(coef_sample)
coef_mean_sample <- lapply(1:sample_size, function(x) compute_TVAR(phi_fwd = result_parcor$mu_fwd_sample[x, , ,],
phi_bwd = result_parcor$mu_bwd_sample[x, , ,],
P_opt = P_opt))
coef_mean_sample <- simplify2array(coef_mean_sample)
coef_quantile <- apply(coef_sample, 1:3, quantile, c(0.025, 0.975))
dim(coef_quantile)
dim(coef_sample)
coef_quantile <- apply(coef_sample, 1:3, quantile, c(0.025, 0.5, 0.975))
dim(coef_quantile)
i <- 1
j <- 1
plot(coef[i, (P+1):(n_t-P), j], xlab = "time", ylab = "value",
type = 'l', main = bquote(phi[.(i)*.(j)]),
ylim = range(coef[i, (P+1):(n_t-P), j],
coef_mean[1, (P+1):(n_t-P), j],
true_ar[i, (P+1):(n_t-P), j],
na.rm = TRUE))
par(mfrow = c(1, 1))
plot(coef[i, (P+1):(n_t-P), j], xlab = "time", ylab = "value",
type = 'l', main = bquote(phi[.(i)*.(j)]),
ylim = range(coef[i, (P+1):(n_t-P), j],
coef_mean[1, (P+1):(n_t-P), j],
true_ar[i, (P+1):(n_t-P), j],
na.rm = TRUE))
lines(true_ar[i, (P+1):(n_t-P), j], type = 'l', col = 'red', lty = 3)
lines(coef_mean[1, (P+1):(n_t-P), j], type = 'l', col = 'blue', lty = 2)
index <- 1:(n_t-2*P)
polygon(c(index,rev(index)), c(coef_quantile[1, i, (P+1):(n_t-P), j],
coef_quantile[3, i, (P+1):(n_t-P), j]))
dim(coef_quantile)
plot(coef[i, (P+1):(n_t-P), j], xlab = "time", ylab = "value",
type = 'l', main = bquote(phi[.(i)*.(j)]),
ylim = range(coef[i, (P+1):(n_t-P), j],
coef_mean[1, (P+1):(n_t-P), j],
true_ar[i, (P+1):(n_t-P), j],
coef_quantile[, i, (P+1):(n_t-P), j],
na.rm = TRUE))
lines(true_ar[i, (P+1):(n_t-P), j], type = 'l', col = 'red', lty = 3)
lines(coef_mean[1, (P+1):(n_t-P), j], type = 'l', col = 'blue', lty = 2)
lines(coef_quantile[1, i, (P+1):(n_t-P), j], type = 'l', col = 'green', lty = 4)
if(j == 1 | i==1 | i==3){
loc <- "bottomright"
}else{
loc <- "topright"
}
lines(coef_quantile[3, i, (P+1):(n_t-P), j], type = 'l', col = 'green', lty = 4)
?polygon
plot(coef[i, (P+1):(n_t-P), j], xlab = "time", ylab = "value",
type = 'l', main = bquote(phi[.(i)*.(j)]),
ylim = range(coef[i, (P+1):(n_t-P), j],
coef_mean[1, (P+1):(n_t-P), j],
true_ar[i, (P+1):(n_t-P), j],
coef_quantile[, i, (P+1):(n_t-P), j],
na.rm = TRUE))
lines(true_ar[i, (P+1):(n_t-P), j], type = 'l', col = 'red', lty = 3)
lines(coef_mean[1, (P+1):(n_t-P), j], type = 'l', col = 'blue', lty = 2)
lines(coef_quantile[1, i, (P+1):(n_t-P), j], type = 'l', col = 'green', lty = 4)
lines(coef_quantile[3, i, (P+1):(n_t-P), j], type = 'l', col = 'green', lty = 4)
polygon(c(index,
rev(index)),
c(coef_quantile[3, i, (P+1):(n_t-P), j],
rev(coef_quantile[1, i, (P+1):(n_t-P), j])), col="skyblue", )
plot(coef[i, (P+1):(n_t-P), j], xlab = "time", ylab = "value",
type = 'l', main = bquote(phi[.(i)*.(j)]),
ylim = range(coef[i, (P+1):(n_t-P), j],
coef_mean[1, (P+1):(n_t-P), j],
true_ar[i, (P+1):(n_t-P), j],
coef_quantile[, i, (P+1):(n_t-P), j],
na.rm = TRUE))
polygon(c(index,
rev(index)),
c(coef_quantile[3, i, (P+1):(n_t-P), j],
rev(coef_quantile[1, i, (P+1):(n_t-P), j])),
col="skyblue", border = )
lines(true_ar[i, (P+1):(n_t-P), j], type = 'l', col = 'red', lty = 3)
lines(coef_mean[1, (P+1):(n_t-P), j], type = 'l', col = 'blue', lty = 2)
lines(coef_quantile[1, i, (P+1):(n_t-P), j], type = 'l', col = 'green', lty = 4)
lines(coef_quantile[3, i, (P+1):(n_t-P), j], type = 'l', col = 'green', lty = 4)
lines(coef[i, (P+1):(n_t-P), j], col = 'black', lty = 1)
plot(coef[i, (P+1):(n_t-P), j], xlab = "time", ylab = "value",
type = 'l', main = bquote(phi[.(i)*.(j)]),
ylim = range(coef[i, (P+1):(n_t-P), j],
coef_mean[1, (P+1):(n_t-P), j],
true_ar[i, (P+1):(n_t-P), j],
coef_quantile[, i, (P+1):(n_t-P), j],
na.rm = TRUE))
polygon(c(index,
rev(index)),
c(coef_quantile[3, i, (P+1):(n_t-P), j],
rev(coef_quantile[1, i, (P+1):(n_t-P), j])),
col="green", border = "green")
lines(coef[i, (P+1):(n_t-P), j], col = 'black', lty = 1)
lines(true_ar[i, (P+1):(n_t-P), j], type = 'l', col = 'red', lty = 3)
lines(coef_mean[1, (P+1):(n_t-P), j], type = 'l', col = 'blue', lty = 2)
lines(coef_quantile[1, i, (P+1):(n_t-P), j], type = 'l', col = 'green', lty = 4)
plot(coef[i, (P+1):(n_t-P), j], xlab = "time", ylab = "value",
type = 'l', main = bquote(phi[.(i)*.(j)]),
ylim = range(coef[i, (P+1):(n_t-P), j],
coef_mean[1, (P+1):(n_t-P), j],
true_ar[i, (P+1):(n_t-P), j],
coef_quantile[, i, (P+1):(n_t-P), j],
na.rm = TRUE))
polygon(c(index,
rev(index)),
c(coef_quantile[3, i, (P+1):(n_t-P), j],
rev(coef_quantile[1, i, (P+1):(n_t-P), j])),
col="skyblue", border = "green")
lines(coef[i, (P+1):(n_t-P), j], col = 'black', lty = 1)
lines(true_ar[i, (P+1):(n_t-P), j], type = 'l', col = 'red', lty = 3)
lines(coef_mean[1, (P+1):(n_t-P), j], type = 'l', col = 'blue', lty = 2)
plot(coef[i, (P+1):(n_t-P), j], xlab = "time", ylab = "value",
type = 'l', main = bquote(phi[.(i)*.(j)]),
ylim = range(coef[i, (P+1):(n_t-P), j],
coef_mean[1, (P+1):(n_t-P), j],
true_ar[i, (P+1):(n_t-P), j],
coef_quantile[, i, (P+1):(n_t-P), j],
na.rm = TRUE))
polygon(c(index,
rev(index)),
c(coef_quantile[3, i, (P+1):(n_t-P), j],
rev(coef_quantile[1, i, (P+1):(n_t-P), j])),
col="skyblue")
plot(coef[i, (P+1):(n_t-P), j], xlab = "time", ylab = "value",
type = 'l', main = bquote(phi[.(i)*.(j)]),
ylim = range(coef[i, (P+1):(n_t-P), j],
coef_mean[1, (P+1):(n_t-P), j],
true_ar[i, (P+1):(n_t-P), j],
coef_quantile[, i, (P+1):(n_t-P), j],
na.rm = TRUE))
polygon(c(index,
rev(index)),
c(coef_quantile[3, i, (P+1):(n_t-P), j],
rev(coef_quantile[1, i, (P+1):(n_t-P), j])),
col="skyblue", border = NA)
lines(coef[i, (P+1):(n_t-P), j], col = 'black', lty = 1)
lines(true_ar[i, (P+1):(n_t-P), j], type = 'l', col = 'red', lty = 3)
lines(coef_mean[1, (P+1):(n_t-P), j], type = 'l',
col = 'blue', lty = 2)
if(j == 1 | i==1 | i==3){
loc <- "bottomright"
}else{
loc <- "topright"
}
legend("bottomright", legend=c("true", "estimated", "mean"),
lty = c(3,1,2), col = c("red", "black", "blue"),
cex = 4)
sim_index <- "simulation_4"
index <- 1:(n_t-2*P)
png(paste0(plot_dir, sim_index, "/scale/ar_coef.png"), width = 2500, height = 2000)
layout(matrix(1:10, 5, 2, byrow = TRUE))
layout.show(n = 10)
par(cex.lab = 2.5, cex.axis = 2.5, cex.main = 3)
for(i in 1:n_I){
for(j in 1:P_opt){
plot(coef[i, (P+1):(n_t-P), j], xlab = "time", ylab = "value",
type = 'l', main = bquote(phi[.(i)*.(j)]),
ylim = range(coef[i, (P+1):(n_t-P), j],
coef_mean[1, (P+1):(n_t-P), j],
true_ar[i, (P+1):(n_t-P), j],
coef_quantile[, i, (P+1):(n_t-P), j],
na.rm = TRUE))
polygon(c(index,
rev(index)),
c(coef_quantile[3, i, (P+1):(n_t-P), j],
rev(coef_quantile[1, i, (P+1):(n_t-P), j])),
col="skyblue", border = NA)
lines(coef[i, (P+1):(n_t-P), j], col = 'black', lty = 1)
lines(true_ar[i, (P+1):(n_t-P), j], type = 'l', col = 'red', lty = 3)
lines(coef_mean[1, (P+1):(n_t-P), j], type = 'l',
col = 'blue', lty = 2)
if(j == 1 | i==1 | i==3){
loc <- "bottomright"
}else{
loc <- "topright"
}
legend("bottomright", legend=c("true", "estimated", "mean"),
lty = c(3,1,2), col = c("red", "black", "blue"),
cex = 4)
}
}
dev.off()
sim_index <- "simulation_4"
index <- 1:(n_t-2*P)
png(paste0(plot_dir, sim_index, "/scale/ar_coef.png"), width = 2500, height = 2000)
layout(matrix(1:10, 5, 2, byrow = TRUE))
layout.show(n = 10)
par(cex.lab = 2.5, cex.axis = 2.5, cex.main = 3)
for(i in 1:n_I){
for(j in 1:P_opt){
plot(coef[i, (P+1):(n_t-P), j], xlab = "time", ylab = "value",
type = 'l', main = bquote(phi[.(i)*.(j)]),
ylim = range(coef[i, (P+1):(n_t-P), j],
coef_mean[1, (P+1):(n_t-P), j],
true_ar[i, (P+1):(n_t-P), j],
coef_quantile[, i, (P+1):(n_t-P), j],
na.rm = TRUE))
polygon(c(index,
rev(index)),
c(coef_quantile[3, i, (P+1):(n_t-P), j],
rev(coef_quantile[1, i, (P+1):(n_t-P), j])),
col="skyblue", border = NA)
lines(coef[i, (P+1):(n_t-P), j], col = 'black', lty = 1)
lines(true_ar[i, (P+1):(n_t-P), j], type = 'l', col = 'red', lty = 3)
lines(coef_mean[1, (P+1):(n_t-P), j], type = 'l',
col = 'blue', lty = 2)
if(j == 1 | i==1 | i==3){
loc <- "bottomright"
}else{
loc <- "topright"
}
legend(loc, legend=c("true", "estimated", "mean"),
lty = c(3,1,2), col = c("red", "black", "blue"),
cex = 3)
}
}
dev.off()
dim(coef_sample)
###########################
#### estimated innovation variance
###########################
sigma2 <- rep(result_parcor$sigma2t_fwd[n_t-P, P_opt], n_t)
dim(coef_sample)
s_sample <- lapply(1:sample_size, function(x) compute_sd(w=w,
phi = coef_sample[, , , x],
sigma2 = sigma2))
## compute spectral density
## span of frequence
w <- seq(0.001, 0.499, by = 0.001)
### spectral density of each time series
s <- compute_sd(w = w,
phi = coef,
sigma2 = sigma2)
### average of spectral density
s_mean <- compute_sd(w=w,
phi= coef_mean,
sigma2 = sigma2)
### True spectral density
s_true <- compute_sd(true_ar, rep(et, n_t), w)
s_sample <- lapply(1:sample_size, function(x) compute_sd(w=w,
phi = coef_sample[, , , x],
sigma2 = sigma2))
library(snowfall)
sfInit(parallel = TRUE, cpus=4, type="SOCK")
sfExport("compute_sd", "w", "coef_sample", "sigma2")
s_sample <- sfLapply(1:sample_size, function(x) compute_sd(w=w,
phi = coef_sample[, , , x],
sigma2 = sigma2))
sfExport("compute_sd", "w", "coef_sample", "sigma2", "cal.tfr")
s_sample <- sfLapply(1:sample_size, function(x) compute_sd(w=w,
phi = coef_sample[, , , x],
sigma2 = sigma2))
sfStop()
dim(coef_quantile)
s_quantile_low <- compute_sd(w=w,
phi=coef_quantile[1, ], sigma2=sigma2)
s_quantile_low <- compute_sd(w=w,
phi=coef_quantile[1, , , ], sigma2=sigma2)
s_quantile2<- compute_sd(w=w,
phi=coef_quantile[2, , , ],
sigma2=sigma2)
i
index <- i
par(cex.lab = 1.5, cex.axis = 1.5, cex.main = 1.5)
draw.density(w = w, index = index, P = P,
n_t = n_t, s = s_quantile1, zlim = range(s_quantile1[[index]][(P+1):(n_t-P),],
s_true[[index]][(P+1):(n_t-P), ]))
s_quantile1 <- compute_sd(w=w,
phi=coef_quantile[1, , , ],
sigma2=sigma2)
s_quantile2<- compute_sd(w=w,
phi=coef_quantile[2, , , ],
sigma2=sigma2)
par(cex.lab = 1.5, cex.axis = 1.5, cex.main = 1.5)
draw.density(w = w, index = index, P = P,
n_t = n_t, s = s_quantile1, zlim = range(s_quantile1[[index]][(P+1):(n_t-P),],
s_true[[index]][(P+1):(n_t-P), ]))
for(i in 1:n_I){
index <- i
png(filename = paste0(plot_dir, sim_index, '/scale/est_', index, 'st.png'))
par(cex.lab = 1.5, cex.axis = 1.5, cex.main = 1.5)
draw.density(w = w, index = index, P = P,
n_t = n_t, s = s, zlim = range(s[[index]][(P+1):(n_t-P),],
s_true[[index]][(P+1):(n_t-P), ]))
dev.off()
index <- i
png(filename = paste0(plot_dir, sim_index, '/scale/true_', index, 'st.png'))
par(cex.lab = 1.5, cex.axis = 1.5, cex.main = 1.5)
draw.density(w = w, index = index, P = P,
n_t = n_t, s = s_true, zlim = range(s[[index]][(P+1):(n_t-P),],
s_true[[index]][(P+1):(n_t-P), ]))
dev.off()
index <- i
png(filename = paste0(plot_dir, sim_index, '/scale/ql_', index, 'st.png'))
par(cex.lab = 1.5, cex.axis = 1.5, cex.main = 1.5)
draw.density(w = w, index = index, P = P,
n_t = n_t, s = s_quantile1, zlim = range(s_quantile1[[index]][(P+1):(n_t-P),],
s_true[[index]][(P+1):(n_t-P), ]))
dev.off()
index <- i
png(filename = paste0(plot_dir, sim_index, '/scale/qu_', index, 'st.png'))
par(cex.lab = 1.5, cex.axis = 1.5, cex.main = 1.5)
draw.density(w = w, index = index, P = P,
n_t = n_t, s = s_quantile2, zlim = range(s_quantile2[[index]][(P+1):(n_t-P),],
s_true[[index]][(P+1):(n_t-P), ]))
dev.off()
}
plot_dir
s_quantile2<- compute_sd(w=w,
phi=coef_quantile[3, , , ],
sigma2=sigma2)
for(i in 1:n_I){
index <- i
png(filename = paste0(plot_dir, sim_index, '/scale/est_', index, 'st.png'))
par(cex.lab = 1.5, cex.axis = 1.5, cex.main = 1.5)
draw.density(w = w, index = index, P = P,
n_t = n_t, s = s, zlim = range(s[[index]][(P+1):(n_t-P),],
s_true[[index]][(P+1):(n_t-P), ]))
dev.off()
index <- i
png(filename = paste0(plot_dir, sim_index, '/scale/true_', index, 'st.png'))
par(cex.lab = 1.5, cex.axis = 1.5, cex.main = 1.5)
draw.density(w = w, index = index, P = P,
n_t = n_t, s = s_true, zlim = range(s[[index]][(P+1):(n_t-P),],
s_true[[index]][(P+1):(n_t-P), ]))
dev.off()
index <- i
png(filename = paste0(plot_dir, sim_index, '/scale/ql_', index, 'st.png'))
par(cex.lab = 1.5, cex.axis = 1.5, cex.main = 1.5)
draw.density(w = w, index = index, P = P,
n_t = n_t, s = s_quantile1, zlim = range(s_quantile1[[index]][(P+1):(n_t-P),],
s_true[[index]][(P+1):(n_t-P), ]))
dev.off()
index <- i
png(filename = paste0(plot_dir, sim_index, '/scale/qu_', index, 'st.png'))
par(cex.lab = 1.5, cex.axis = 1.5, cex.main = 1.5)
draw.density(w = w, index = index, P = P,
n_t = n_t, s = s_quantile2, zlim = range(s_quantile2[[index]][(P+1):(n_t-P),],
s_true[[index]][(P+1):(n_t-P), ]))
dev.off()
}
for(i in 1:n_I){
index <- i
png(filename = paste0(plot_dir, sim_index, '/scale/est_', index, 'st.png'))
par(cex.lab = 1.5, cex.axis = 1.5, cex.main = 1.5)
draw.density(w = w, index = index, P = P,
n_t = n_t, s = s, zlim = range(s[[index]][(P+1):(n_t-P),],
s_quantile1[[index]][(P+1):(n_t-P),],
s_quantile2[[index]][(P+1):(n_t-P),],
s_true[[index]][(P+1):(n_t-P), ]))
dev.off()
index <- i
png(filename = paste0(plot_dir, sim_index, '/scale/true_', index, 'st.png'))
par(cex.lab = 1.5, cex.axis = 1.5, cex.main = 1.5)
draw.density(w = w, index = index, P = P,
n_t = n_t, s = s_true, zlim = range(s[[index]][(P+1):(n_t-P),],
s_quantile1[[index]][(P+1):(n_t-P),],
s_quantile2[[index]][(P+1):(n_t-P),],
s_true[[index]][(P+1):(n_t-P), ]))
dev.off()
index <- i
png(filename = paste0(plot_dir, sim_index, '/scale/ql_', index, 'st.png'))
par(cex.lab = 1.5, cex.axis = 1.5, cex.main = 1.5)
draw.density(w = w, index = index, P = P,
n_t = n_t, s = s_quantile1, zlim = range(s[[index]][(P+1):(n_t-P),],
s_quantile1[[index]][(P+1):(n_t-P),],
s_quantile2[[index]][(P+1):(n_t-P),],
s_true[[index]][(P+1):(n_t-P), ]))
dev.off()
index <- i
png(filename = paste0(plot_dir, sim_index, '/scale/qu_', index, 'st.png'))
par(cex.lab = 1.5, cex.axis = 1.5, cex.main = 1.5)
draw.density(w = w, index = index, P = P,
n_t = n_t, s = s_quantile2, zlim = range(s[[index]][(P+1):(n_t-P),],
s_quantile1[[index]][(P+1):(n_t-P),],
s_quantile2[[index]][(P+1):(n_t-P),],
s_true[[index]][(P+1):(n_t-P), ]))
dev.off()
}
library(snowfall)
sfInit(parallel = TRUE, cpus=4, type="SOCK")
sfExport("compute_sd", "w", "coef_sample", "sigma2", "cal.tfr")
s_sample <- sfLapply(1:(sample_size/2), function(x) compute_sd(w=w,
phi = coef_sample[, , , x],
sigma2 = sigma2))
sfStop()
library(snowfall)
sfInit(parallel = TRUE, cpus=5, type="SOCK")
sfExport("compute_sd", "w", "coef_sample", "sigma2", "cal.tfr")
s_sample <- sfLapply(1:(sample_size/2), function(x) compute_sd(w=w,
phi = coef_sample[, , , x],
sigma2 = sigma2))
sfStop()
for(i in 1:n_I){
index <- i
png(filename = paste0(plot_dir, sim_index, '/scale/est_', index, 'st.png'))
par(cex.lab = 1.5, cex.axis = 1.5, cex.main = 1.5)
draw.density(w = w, index = index, P = P,
n_t = n_t, s = s, zlim = range(s[[index]][(P+1):(n_t-P),],
#s_quantile1[[index]][(P+1):(n_t-P),],
#s_quantile2[[index]][(P+1):(n_t-P),],
s_true[[index]][(P+1):(n_t-P), ]))
dev.off()
index <- i
png(filename = paste0(plot_dir, sim_index, '/scale/true_', index, 'st.png'))
par(cex.lab = 1.5, cex.axis = 1.5, cex.main = 1.5)
draw.density(w = w, index = index, P = P,
n_t = n_t, s = s_true, zlim = range(s[[index]][(P+1):(n_t-P),],
#s_quantile1[[index]][(P+1):(n_t-P),],
#s_quantile2[[index]][(P+1):(n_t-P),],
s_true[[index]][(P+1):(n_t-P), ]))
dev.off()
# index <- i
# png(filename = paste0(plot_dir, sim_index, '/scale/ql_', index, 'st.png'))
# par(cex.lab = 1.5, cex.axis = 1.5, cex.main = 1.5)
# draw.density(w = w, index = index, P = P,
#              n_t = n_t, s = s_quantile1, zlim = range(s[[index]][(P+1):(n_t-P),],
#                                                       s_quantile1[[index]][(P+1):(n_t-P),],
#                                                       s_quantile2[[index]][(P+1):(n_t-P),],
#                                                       s_true[[index]][(P+1):(n_t-P), ]))
# dev.off()
#
#
# index <- i
# png(filename = paste0(plot_dir, sim_index, '/scale/qu_', index, 'st.png'))
# par(cex.lab = 1.5, cex.axis = 1.5, cex.main = 1.5)
# draw.density(w = w, index = index, P = P,
#              n_t = n_t, s = s_quantile2, zlim = range(s[[index]][(P+1):(n_t-P),],
#                                                       s_quantile1[[index]][(P+1):(n_t-P),],
#                                                       s_quantile2[[index]][(P+1):(n_t-P),],
#                                                       s_true[[index]][(P+1):(n_t-P), ]))
# dev.off()
}
